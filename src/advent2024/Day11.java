package advent2024;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Stream;

public class Day11 extends Day {
  protected Day11() {
    super(11);
  }
  // If the stone is engraved with the number 0, it is replaced by a
  // stone engraved with the number 1.
  //
  // If the stone is engraved with a number that has an even number of
  // digits, it is replaced by two stones. The left half of the digits
  // are engraved on the new left stone, and the right half of the
  // digits are engraved on the new right stone. (The new numbers don't
  // keep extra leading zeroes: 1000 would become stones 10 and 0.)
  //
  // If none of the other rules apply, the stone is replaced by a new
  // stone; the old stone's number multiplied by 2024 is engraved on the
  // new stone.
  List<Long> blink(List<Long> stones) {
    List<Long> newList = new ArrayList<>(stones.size());
    for (var stone : stones) {
      if (stone == 0) {
        newList.add(1L);
      } else {
        var string = String.valueOf(stone);
        if (string.length() % 2 == 0) {
          newList.add(Long.valueOf(string.substring(0, string.length() / 2)));
          newList.add(Long.valueOf(string.substring(string.length() / 2)));
        } else {
          newList.add(stone * 2024);
        }
      }
    }
    return newList;
  }

  @Override
  String part1() {
    var stones = Stream.iterate(Support.longs(data), this::blink)
        .skip(25)
        .findFirst()
        .orElseThrow();

    return String.valueOf(stones.size());
  }

  // Recursively count the number of stones generated by a stone at a depth.
  long count(Pair<Long, Integer> args) {
    long stone = args.l();
    int depth = args.r();
    if (depth-- == 0) {
      return 1;
    }
    if (stone == 0) {
      return countMemo(1, depth);
    }
    var s = String.valueOf(stone);
    if (s.length() % 2 == 0) {
      return countMemo(Long.parseLong(s.substring(0, s.length() / 2)), depth) +
          countMemo(Long.parseLong(s.substring(s.length() / 2)), depth);
    }
    return countMemo(stone * 2024, depth);
  }

  static Map<Pair<Long, Integer>, Long> CACHE = new HashMap<>();

  long countMemo(long stone, int depth) {
    return Support.computeIfAbsent(CACHE, Pair.of(stone, depth), this::count);
  }

  @Override
  String part2() {
    var total = Support.longStream(data).map(stone -> countMemo(stone, 75)).sum();
    return String.valueOf(total);
  }

  public static void main(String[] args) {
    var day = new Day11();
    System.out.println(day.part1().equals("213625"));
    System.out.println(day.part2().equals("252442982856820"));
  }
}
